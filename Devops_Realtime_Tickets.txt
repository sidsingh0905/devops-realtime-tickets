ğŸ« TICKET #1 â€” BASTION HOST (DEV ENV)
ğŸ“Œ Ticket Description (Real-World Style)

From: Security Team
Environment: DEV
Title: Secure SSH access to private EC2 instances
Problem:
Developers need SSH access to EC2 instances that are deployed in a private subnet, but no EC2 should have a public IP.


Internet
   |
[ IGW ]
   |
Public Subnet (10.0.1.0/24)
   |
[Bastion Host]  <-- SSH allowed only from your IP
   |
Private Subnet (10.0.2.0/24)
   |
[App EC2]  <-- NO public IP


ğŸ§  WHY THIS ARCHITECTURE EXISTS (INTERVIEW CORE)
â“ Why Bastion Host?

Direct SSH to private EC2 is not possible

Public IP on app servers = security risk

Bastion acts as single controlled entry point

ğŸ‘‰ Interview line:

â€œA Bastion Host provides controlled administrative access to private resources without exposing them directly to the internet.â€

â“ Why public + private subnet?

Public subnet â†’ resources needing internet access

Private subnet â†’ internal workloads

ğŸ‘‰ Interview follow-up:

â€œBy default, private subnets cannot reach the internet.â€

ğŸ§± HIGH-LEVEL STEPS (DO NOT SKIP THIS)

Before writing code, memorize this order:

VPC

Subnets (public + private)

Internet Gateway

Route Tables

Security Groups

EC2 (Bastion + App)

âš ï¸ Interviewers often ask:

â€œWhy this order?â€

Answer:

â€œBecause dependencies exist. Subnets need VPC, routes need IGW, EC2 needs subnets and security groups.â€

ğŸŸ¢ STEP 1 â€” VPC (YOU ALREADY STARTED THIS)

ğŸ“ terraform/networking/main.tf

resource "aws_vpc" "dev_vpc" {
  cidr_block           = "10.0.0.0/16"
  enable_dns_support   = true
  enable_dns_hostnames = true

  tags = {
    Name = "dev-vpc"
  }
}

WHY:

/16 gives room for growth

DNS enabled â†’ required for EC2 name resolution

Interviewer cross-question:

Why not /24 for VPC?

Correct answer:

/24 is too small; VPC should allow subnet expansion.

ğŸŸ¢ STEP 2 â€” SUBNETS (PUBLIC + PRIVATE)
Public Subnet
resource "aws_subnet" "public_subnet" {
  vpc_id                  = aws_vpc.dev_vpc.id
  cidr_block              = "10.0.1.0/24"
  availability_zone       = "ap-south-1a"
  map_public_ip_on_launch = true

  tags = {
    Name = "dev-public-subnet"
  }
}

Private Subnet
resource "aws_subnet" "private_subnet" {
  vpc_id            = aws_vpc.dev_vpc.id
  cidr_block        = "10.0.2.0/24"
  availability_zone = "ap-south-1a"

  tags = {
    Name = "dev-private-subnet"
  }
}

WHY:

Public subnet auto-assigns public IP

Private subnet does NOT

Interviewer trap:

â€œDoes a subnet become public just by name?â€

Correct answer:

â€œNo. A subnet is public only if its route table has a route to an Internet Gateway.â€

ğŸŸ¢ STEP 3 â€” INTERNET GATEWAY
resource "aws_internet_gateway" "igw" {
  vpc_id = aws_vpc.dev_vpc.id

  tags = {
    Name = "dev-igw"
  }
}

WHY:

IGW allows internet traffic

Without it â†’ no inbound/outbound internet

Cross-question:

Can private subnet use IGW directly?

Correct:

âŒ No â€” only public subnets should route to IGW.

ğŸŸ¢ STEP 4 â€” ROUTE TABLES
Public Route Table
resource "aws_route_table" "public_rt" {
  vpc_id = aws_vpc.dev_vpc.id

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.igw.id
  }

  tags = {
    Name = "public-rt"
  }
}

Associate with Public Subnet
resource "aws_route_table_association" "public_assoc" {
  subnet_id      = aws_subnet.public_subnet.id
  route_table_id = aws_route_table.public_rt.id
}

WHY:

0.0.0.0/0 â†’ all internet traffic

Only public subnet is associated

Interview follow-up:

How many route tables can a subnet have?

Answer:

One.

ğŸŸ¢ STEP 5 â€” SECURITY GROUPS (MOST ASKED)
Bastion Security Group
resource "aws_security_group" "bastion_sg" {
  name   = "bastion-sg"
  vpc_id = aws_vpc.dev_vpc.id

  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["YOUR_PUBLIC_IP/32"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

App EC2 Security Group
resource "aws_security_group" "private_ec2_sg" {
  name   = "private-ec2-sg"
  vpc_id = aws_vpc.dev_vpc.id

  ingress {
    from_port       = 22
    to_port         = 22
    protocol        = "tcp"
    security_groups = [aws_security_group.bastion_sg.id]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

WHY:

App EC2 allows SSH only from Bastion

No CIDR-based access

ğŸ”¥ Interview GOLD answer:

â€œWe allow security group to security group access instead of CIDR, which is more secure and dynamic.â€

ğŸŸ¢ STEP 6 â€” EC2 INSTANCES
Bastion Host
resource "aws_instance" "bastion" {
  ami                         = "ami-xxxxxxxx"
  instance_type               = "t2.micro"
  subnet_id                   = aws_subnet.public_subnet.id
  associate_public_ip_address = true
  vpc_security_group_ids      = [aws_security_group.bastion_sg.id]
  key_name                    = "your-key"

  tags = {
    Name = "dev-bastion"
  }
}

Private App EC2
resource "aws_instance" "private_ec2" {
  ami                    = "ami-xxxxxxxx"
  instance_type          = "t2.micro"
  subnet_id              = aws_subnet.private_subnet.id
  vpc_security_group_ids = [aws_security_group.private_ec2_sg.id]
  key_name               = "your-key"

  tags = {
    Name = "dev-private-ec2"
  }
}

ğŸ§  FINAL INTERVIEW CROSS-QUESTIONS (YOU MUST ANSWER)

Why Bastion over VPN?

Can Bastion be auto-scaled?

How do you harden Bastion security further?

How do you remove Bastion in production?

What happens if Bastion goes down?

ğŸ‘‰ If you want, Iâ€™ll make you answer these verbally next.

ğŸ§ª HOW YOU SHOULD PRACTICE (IMPORTANT)
DO NOT COPY-PASTE

Instead:

Write code

Break it

Fix it

Explain it aloud

Thatâ€™s how interview confidence comes.

ğŸ› ï¸ EXECUTION STEPS (FOLLOW THIS ORDER)

Write code step-by-step

terraform init

terraform plan

Review resources

terraform apply

SSH â†’ Bastion â†’ Private EC2

terraform destroy after testing

ğŸ‘‰ NEXT MOVE

Reply with:

â€œTicket 1 VPC + Subnets doneâ€
or

Ask doubts in ANY step

Next, weâ€™ll add:
â¡ï¸ NAT Gateway
â¡ï¸ Explain why private subnet needs it
â¡ï¸ Production-grade reasoning

Youâ€™re now doing real DevOps, not theory ğŸ’ª


























































================================
ğŸ« TICKET 01 â€“ BASTION HOST SETUP
================================

Status: âœ… Completed
Environment: AWS â€“ us-east-1
Tooling: Terraform, EC2, VPC, Security Groups

ğŸ“Œ Problem Statement

Developers need SSH access to EC2 instances deployed in a private subnet.
For security reasons, EC2 instances should not have public IP addresses.

ğŸ¯ Objective

Enable secure SSH access to private EC2 instances

Prevent direct internet access to application servers

Follow AWS security best practices




ğŸ—ï¸ Architecture Summary

VPC with CIDR 10.0.0.0/16

Public subnet for Bastion Host

Private subnet for application EC2

Internet Gateway attached to VPC

Security Groups with SG-to-SG SSH access



ğŸ” Security Design

Bastion Host:

Deployed in public subnet

SSH allowed only from trusted IP

Private EC2:

Deployed in private subnet

SSH allowed only from Bastion Security Group

No public IP assigned


ğŸ› ï¸ Implementation Steps

Created VPC and subnets using Terraform

Created Internet Gateway and public route table

Created Bastion Security Group with restricted SSH

Created Private EC2 Security Group allowing SSH only from Bastion SG

Used Terraform data source to fetch latest Amazon Linux 2 AMI

Launched Bastion EC2 in public subnet

Launched Private EC2 in private subnet


âœ… Validation Performed

Verified private EC2 has no public IP

SSH from local machine â†’ Bastion Host (successful)

SSH from Bastion Host â†’ Private EC2 using private IP (successful)

Direct SSH from local machine â†’ Private EC2 (failed as expected)


ğŸ§  Key Learnings

Bastion Host provides secure administrative access

Security Group to Security Group rules are more secure than CIDR-based rules

Ingress controls incoming traffic, egress controls outgoing traffic

Private EC2 instances remain isolated from the internet



ğŸ¤ Interview Talking Points

Why Bastion Host is needed

Difference between Bastion Host and NAT Gateway

Ingress vs Egress in Security Groups

How to validate private subnet security














ğŸ« Ticket #4 â€“ CI/CD Pipeline using GitHub Actions (Deploy to EC2)
ğŸ“Œ Problem Statement

Developers want an automated deployment mechanism so that whenever application code is pushed to GitHub, it gets automatically deployed to an EC2 instance without any manual SSH or file copy.

Key Requirements:

No manual deployment

Secure access to EC2

Deployment should happen only when application code changes

CI/CD should be reliable and repeatable

ğŸ—ï¸ Architecture Overview
Developer Push â†’ GitHub Repository
        |
        v
GitHub Actions (CI/CD Pipeline)
        |
        v
SSH (Secure Copy + Remote Commands)
        |
        v
EC2 Instance (Nginx serving application)

ğŸ§° Tools & Technologies Used

GitHub Actions â€“ CI/CD orchestration

AWS EC2 (Amazon Linux 2) â€“ Deployment target

Nginx â€“ Web server

SSH / SCP â€“ Secure deployment

GitHub Repository Secrets â€“ Secure credential management

ğŸ” Security Considerations

No credentials are hardcoded in the repository

SSH private key is stored securely in GitHub Actions Repository Secrets

SSH access is controlled via Security Groups

Secrets are injected only at runtime

ğŸ”‘ GitHub Secrets Configuration

Configured under:

GitHub Repo â†’ Settings â†’ Secrets and variables â†’ Actions â†’ Repository secrets

Secret Name	Description
EC2_HOST	Public IPv4 address of EC2
EC2_USER	SSH username (ec2-user)
EC2_SSH_KEY	Full private key content (.pem file)
ğŸ“‚ Repository Structure (Relevant to Ticket #4)
.github/
â””â”€â”€ workflows/
    â””â”€â”€ deploy.yml

python/
â””â”€â”€ ticket-04-app/
    â””â”€â”€ index.html

âš™ï¸ GitHub Actions Workflow (deploy.yml)
Trigger Condition
on:
  push:
    paths:
      - "python/ticket-04-app/**"


ğŸ‘‰ Pipeline runs only when application code changes, avoiding unnecessary deployments.

Deployment Logic (Core Steps)

Checkout latest code

Configure SSH on GitHub runner

Copy application file to EC2 using SCP

Move file to Nginx web root using sudo

Restart Nginx to reflect changes

Deployment Commands Explained
run: |
  scp python/ticket-04-app/index.html ec2-user@${{ secrets.EC2_HOST }}:/tmp/index.html

  ssh ec2-user@${{ secrets.EC2_HOST }} "
    sudo mv /tmp/index.html /usr/share/nginx/html/index.html
    sudo systemctl restart nginx
  "

Why /tmp?

Writable directory

Avoids permission issues

Why sudo?

Nginx web root is owned by root

Why restart Nginx?

Ensures latest content is served

âœ… Validation Steps

Push a change to python/ticket-04-app/index.html

Verify workflow execution in GitHub Actions tab

Check deployment logs for success

Open browser:

http://<EC2_PUBLIC_IP>


Confirm updated content is visible

âŒ Common Issues Faced & Fixes
Issue: Permission denied (publickey)

Cause:

Incorrect SSH user

Wrong private key in secrets

EC2 launched with a different key pair

Fix:

Verified EC2 SSH user (ec2-user)

Re-added correct PEM content to secrets

Confirmed key pair attached to EC2

Issue: Website not accessible

Cause:

HTTP (80) not allowed in Security Group

Fix:

Added inbound rule for HTTP port 80

Issue: Pipeline didnâ€™t trigger

Cause:

Incorrect paths filter

Fix:

Corrected path to python/ticket-04-app/**

ğŸ¯ Outcome

Fully automated CI/CD pipeline implemented

Zero manual deployment steps

Secure and auditable deployment process

Clear separation between infrastructure and deployment logic

ğŸ¤ Interview-Ready Summary

â€œI implemented a GitHub Actions CI/CD pipeline that deploys application changes automatically to an EC2 instance using SSH. Secrets are securely managed at the repository level, and deployments are triggered only when application code changes.â€

ğŸ§  Key Learnings

Difference between uses and run in GitHub Actions
Importance of correct SSH user and key management
How CI/CD depends on solid infrastructure baseline
Debugging real-world CI/CD authentication issues




ğŸ« DevOps Realtime Ticket 5
Environment-Based Deployment using Ansible + GitHub Actions

ğŸ“Œ Ticket Title

Environment-based CI/CD Deployment (DEV / QA / PROD) using Ansible & GitHub Actions


ğŸ§¾ Business Requirement

The application must be deployed to different environments (DEV, QA, PROD) automatically based on the Git branch.
Server configuration should be automated and reusable.
CI/CD pipeline should not perform server-level configuration.


ğŸ¯ Objectives

Automate server preparation using Ansible

Implement branch-based deployments using GitHub Actions

Maintain environment isolation (DEV / QA / PROD)

Use a single EC2 initially to reduce cost

Follow real-world DevOps best practices


ğŸ— Architecture Overview
Developer (Local)
   |
   |  git push (dev / qa / main)
   v
GitHub Actions (CI/CD)
   |
   |  SCP over SSH
   v
Amazon EC2
   â”œâ”€â”€ /var/www/dev
   â”œâ”€â”€ /var/www/qa
   â””â”€â”€ /var/www/prod


ğŸ›  Solution Approach

The solution was implemented in two layers:

1ï¸âƒ£ Server Configuration Layer (Ansible)
2ï¸âƒ£ Deployment Layer (GitHub Actions)

This separation ensures clean DevOps responsibility boundaries.


ART 1: Server Preparation using Ansible
Why Ansible?

Agentless (uses SSH)

Idempotent

Ideal for OS-level configuration

Keeps CI/CD pipelines lightweight

âœ… Ansible Control Node Setup

Installed Ubuntu via WSL on Windows

Installed Ansible using apt

Used Ubuntu as Ansible Control Node

âœ… Ansible Inventory Configuration
[dev]
98.84.37.49 ansible_user=ec2-user ansible_ssh_private_key_file=~/.ssh/devops-bastion-key.pem


This defines:

Target EC2

SSH user

Private key for authentication

âœ… Connectivity Validation
ansible dev -i inventory -m ping


Result:

SUCCESS => ping: pong


This confirmed:

SSH connectivity

Correct key usage

EC2 security group configuration

âœ… Ansible Playbook (Server Configuration)
- name: Prepare DEV EC2 for application deployments
  hosts: dev
  become: true

  tasks:
    - name: Update all packages
      yum:
        name: "*"
        state: latest

    - name: Install required packages
      yum:
        name:
          - nginx
        state: present

    - name: Create environment directories
      file:
        path: /var/www/{{ item }}
        state: directory
        owner: ec2-user
        group: ec2-user
        mode: '0755'
      loop:
        - dev
        - qa
        - prod

    - name: Start and enable nginx
      service:
        name: nginx
        state: started
        enabled: true

âœ… Outcome of Ansible Execution

Nginx installed and running

Environment directories created:

/var/www/dev
/var/www/qa
/var/www/prod


Correct ownership & permissions set

Server became deployment-ready

ğŸ§  Key DevOps Principle Applied

Ansible handles configuration, CI/CD handles deployment.

ğŸ”¹ PART 2: CI/CD using GitHub Actions
âœ… Repository Structure
.github/workflows/deploy.yml
python/
 â””â”€â”€ ticket-04-app/
     â””â”€â”€ index.html

âœ… GitHub Actions Workflow
name: Env Based Deployment to EC2

on:
  push:
    branches:
      - dev
      - qa
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy based on branch
        run: |
          if [ "${{ github.ref_name }}" = "dev" ]; then
            TARGET_DIR="/var/www/dev"
          elif [ "${{ github.ref_name }}" = "qa" ]; then
            TARGET_DIR="/var/www/qa"
          else
            TARGET_DIR="/var/www/prod"
          fi

          scp python/ticket-04-app/index.html \
          ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:$TARGET_DIR/

ğŸ”„ How Environment Detection Works

GitHub automatically sets:

github.ref_name = dev | qa | main


Deployment directory is selected dynamically

No hardcoding of environment values

ğŸ” Secrets Used

Configured in GitHub Actions Secrets:

Secret	Description
EC2_HOST	EC2 public IP
EC2_USER	ec2-user
EC2_SSH_KEY	Private SSH key
ğŸ” Deployment Flow (End-to-End)
git push origin dev
â†“
GitHub Actions triggered
â†“
Branch detected: dev
â†“
TARGET_DIR=/var/www/dev
â†“
Artifact copied to EC2


Same logic applies for qa and main.

âœ… Validation Performed

GitHub Actions run status checked

Verified files on EC2:

ls /var/www/dev
ls /var/www/qa
ls /var/www/prod


Confirmed no cross-environment overwrite

Re-ran pipeline using empty commits to validate idempotency

ğŸ”„ Environment Promotion Strategy
git checkout qa
git merge dev
git push origin qa


This ensures:

DEV validated before QA

Controlled promotion

Audit-friendly Git history

ğŸ§  Interview-Ready Explanation

â€œWe implemented environment-based deployments using GitHub Actions, where branch names dynamically determine the target environment. Ansible was used to standardize server configuration, while CI/CD pipelines focused solely on deployments.â€

ğŸ“ˆ Benefits Achieved

Zero manual server configuration

Clear separation of concerns

Scalable CI/CD design

Cost-effective single-EC2 approach

Production-aligned DevOps workflow

ğŸ”œ Next Planned Enhancements

Ticket 6: Zero-Downtime Deployment (Blue-Green)

Terraform for infra creation

Secrets Manager integration

Docker & ECR

Monitoring & logging

âœ… Ticket Status

Status: âœ… Completed
Outcome: Successful environment-based CI/CD deployment using Ansible & GitHub Actions
